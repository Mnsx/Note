# 认识时间复杂度

常数时间的操作 

一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。 

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体 来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作， 进而总结出常数操作数量的表达式。 

在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那 么时间复杂度为O(f(N))。 

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行 时间，也就是“常数项时间”。

# 选择排序、冒泡排序

时间复杂度O(N^2)，额外空间复杂度O(1)

* 选择排序

  ```java
  public class SelectionSort {
      private static Scanner scanner = new Scanner(System.in);
  
      private static int[] dataIn() {
          System.out.println("输入数组长度:");
          int length = scanner.nextInt();
          int[] ints = new int[length];
          System.out.println("输入数组的内容:");
          for (int i = 0; i < length; ++i) {
              ints[i] = scanner.nextInt();
          }
          return ints;
      }
  
      public static void main(String[] args) {
          int[] ints = dataIn();
          display(ints);
          selectionSort(ints);
          display(ints);
      }
  
      private static void display(int[] ints) {
          for (int i : ints) {
              System.out.print(i + " ");
          }
      }
  
      private static void selectionSort(int[] ints) {
          int length = ints.length;
  
          for (int i = 0; i < length - 1; ++i) {
              int min = i;
              for (int j = i + 1; j < length; ++j) {
                  if (ints[j] < ints[min]) {
                      min = j;
                  }
              }
              if (min != i) {
                  swap(ints, i, min);
              }
          }
      }
  
      private static void swap(int[] ints, int i, int j) {
          ints[i] = ints[i] ^ ints[j];
          ints[j] = ints[i] ^ ints[j];
          ints[i] = ints[i] ^ ints[j];
      }
  }
  
  ```

* 冒泡排序

  ```java
  public class BubbleSort {
      private static Scanner scanner = new Scanner(System.in);
  
      private static int[] dataIn() {
          System.out.println("输入数组长度:");
          int length = scanner.nextInt();
          int[] ints = new int[length];
          System.out.println("输入数组的内容:");
          for (int i = 0; i < length; ++i) {
              ints[i] = scanner.nextInt();
          }
          return ints;
      }
  
      public static void main(String[] args) {
          int[] ints = dataIn();
          display(ints);
          bubbleSort(ints);
          display(ints);
      }
  
      private static void display(int[] ints) {
          for (int i : ints) {
              System.out.print(i + " ");
          }
      }
  
      private static void bubbleSort(int[] ints) {
          int length = ints.length;
  
          for (int i = 0; i < length - 1; ++i) {
              for (int j = i + 1; j < length; ++j) {
                  if (ints[i] > ints[j]) {
                      swap(ints, i, j);
                  }
              }
          }
      }
  
      private static void swap(int[] ints, int i, int j) {
          ints[i] = ints[i] ^ ints[j];
          ints[j] = ints[i] ^ ints[j];
          ints[i] = ints[i] ^ ints[j];
      }
  }
  ```

# 插入排序

时间复杂度O(N^2)，额外空间复杂度O(1) 

算法流程按照最差情况来估计时间复杂度

```java
public class InsertionSort {
    private static Scanner scanner = new Scanner(System.in);

    private static int[] dataIn() {
        System.out.println("输入数组长度:");
        int length = scanner.nextInt();
        int[] ints = new int[length];
        System.out.println("输入数组的内容:");
        for (int i = 0; i < length; ++i) {
            ints[i] = scanner.nextInt();
        }
        return ints;
    }

    public static void main(String[] args) {
        int[] ints = dataIn();
        display(ints);
        insertionSort(ints);
        display(ints);
    }

    private static void display(int[] ints) {
        for (int i : ints) {
            System.out.print(i + " ");
        }
    }

    private static void insertionSort(int[] ints) {
        int length = ints.length;

        for (int i = 1; i < length; ++i) {
            int j = i;
            int temp = ints[i];
            while (j > 0 && temp < ints[j - 1]) {
                ints[j] = ints[j - 1];
                j--;
            }
            if (j != i) {
                ints[j] = temp;
            }
        }
    }
}
```

# 异或运算的性质与扩展

1）0^N == N N^N == 0 

2）异或运算满足交换律和结合率 

3）不用额外变量交换两个数 

4）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数 

5）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数

# 二分法的详解与扩展

1）在一个有序数组中，找某个数是否存在 

```java
public class BinarySearch {
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("请输入参数个数:");
        int length = scanner.nextInt();
        int[] params = new int[length];
        System.out.println("请输入参数:");
        for (int i = 0; i < length; ++i) {
            params[i] = scanner.nextInt();
        }
        System.out.println("请输入目标参数:");
        int target = scanner.nextInt();
        int result = binarySearch(params, target);
        System.out.println(result);
    }

    public static int binarySearch(int[] params, int target) {
        int l = 0, r = params.length - 1;
        while (l <= r) {
            int mid = l + ((r - l) >> 1);

            if (params[mid] == target) {
                return mid;
            } else if (params[mid] > target) {
                r = mid + 1;
            } else {
                l = mid - 1;
            }
        }
        return -1;
    }
}
```

2）在一个有序数组中，找>=某个数最左侧的位置 

```java
public class dichotomy1 {
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("请输入参数个数:");
        int length = scanner.nextInt();
        int[] params = new int[length];
        System.out.println("请输入参数:");
        for (int i = 0; i < length; ++i) {
            params[i] = scanner.nextInt();
        }
        System.out.println("请输入目标参数:");
        int target = scanner.nextInt();
        int result = binarySearch(params, target);
        System.out.println(result);
    }

    public static int binarySearch(int[] params, int target) {
        int l = 0, r = params.length - 1;
        int index = 0;
        while (l <= r) {
            int mid = l + ((r - l) >> 1);

            if (params[mid] < target) {
                l = mid + 1;
            } else if (params[mid] >= target) {
                r = mid - 1;
                index = mid;
            }
        }
        return index;
    }
}
```

3）局部最小值问题

```java
public class LocalMinimum {
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("请输入参数个数:");
        int length = scanner.nextInt();
        int[] params = new int[length];
        System.out.println("请输入参数:");
        for (int i = 0; i < length; ++i) {
            params[i] = scanner.nextInt();
        }
        int result = fun(params);
        System.out.println(result);
    }

    public static int fun(int[] params) {
        int l = 0, r = params.length - 1;
        if (params[0] < params[1]) {
            return 0;
        }
        if (params[r] < params[r - 1]) {
            return r;
        }
        while (l < r) {
            int mid = l + ((r - l) >> 1);

            if (params[mid] < params[mid + 1] && params[mid] < params[mid - 1]) {
                return mid;
            } else if (params[mid] > params[mid + 1]) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return -1;
    }
}
```

# 对数器的概念和使用

1，有一个你想要测的方法a 

2，实现复杂度不好但是容易实现的方法b 

3，实现一个随机样本产生器 

4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。 

5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者 方法b 

6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

# 递归行为master公式

剖析递归行为和递归行为时间复杂度的估算 

用递归方法找一个数组中的最大值，系统上到底是怎么做的？ 

master公式的使用 

* T(N) = a*T(N/b) + O(N^d) 
  1) log(b,a) > d -> 复杂度为O(N^log(b,a)) 
  2) log(b,a) = d -> 复杂度为O(N^d * logN) 
  3) log(b,a) < d -> 复杂度为O(N^d) 

# 归并排序

归并排序 

1）整体就是一个简单递归，左边排好序、右边排好序、让其整体有序 

2）让其整体有序的过程里用了排外序方法 

3）利用master公式来求解时间复杂度 

4）归并排序的实质 

时间复杂度O(N*logN)，额外空间复杂度O(N)

```java
public class MergeSort {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("请输入数组个数:");
        int n = scanner.nextInt();

        System.out.println("请输入数组的数:");
        int[] in = new int[n];
        for (int i = 0; i < n; ++i) {
            in[i] = scanner.nextInt();
        }

        process(in, 0, in.length - 1);

        for (int i : in) {
            System.out.print(i + " ");
        }
    }

    public static void process(int[] in, int l, int r) {
        if (l == r) {
            return ;
        }

        int mid = l + ((r -l) >> 1);

        process(in, l, mid);
        process(in, mid + 1, r);

        merge(in, l, mid, r);
    }

    public static void merge(int[] in, int l, int mid, int r) {
        int[] help = new int[r - l + 1];

        int cur = 0, i = l, j = mid + 1;

        while (i <= mid && j <= r) {
            help[cur++] = in[i] <= in[j] ? in[i++] : in[j++];
        }

        while (i <= mid) {
            help[cur++] = in[i++];
        }

        while (j <= r) {
            help[cur++] = in[j++];
        }

        for (int k = 0; k < help.length; ++k) {
            in[l + k] = help[k];
        }
    }
}
```

## 小和问题和逆序对问题

## 小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组 的小和。求一个数组 的小和。 

> 例子:[1,3,4,2,5] 1左边比1小的数，没有; 3左边比3小的数，1; 4左 边比4小的数，1、3; 2左边比2小的数，1; 5左边比5小的数，1、3、4、 2; 所以小和为1+1+3+1+1+3+4+2=16

```java
public class SmallAndProblem {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("请输入数组个数:");
        int n = scanner.nextInt();

        System.out.println("请输入数组的数:");
        int[] in = new int[n];
        for (int i = 0; i < n; ++i) {
            in[i] = scanner.nextInt();
        }

        int count = process(in, 0, in.length - 1);

        System.out.println(count);
    }

    public static int process(int[] in, int l, int r) {
        if (l == r) {
            return 0;
        }

        int mid = l + ((r -l) >> 1);

        return process(in, l, mid) + process(in, mid + 1, r) + merge(in, l, mid, r);
    }

    public static int merge(int[] in, int l, int mid, int r) {
        int count = 0;

        int[] help = new int[r - l + 1];

        int cur = 0, i = l, j = mid + 1;

        while (i <= mid && j <= r) {
            if (in[i] < in[j]) {
                count += in[i] * (r - j + 1);
                help[cur++] = in[i++];
            } else {
                help[cur++] = in[j++];
            }
        }

        while (i <= mid) {
            help[cur++] = in[i++];
        }

        while (j <= r) {
            help[cur++] = in[j++];
        }

        for (int k = 0; k < help.length; ++k) {
            in[l + k] = help[k];
        }

        return count;
    }
}
```

## 逆序对问题

逆序对问题 在一个数组中，左边的数如果比右边的数大，则折两个数 构成一个逆序对，请打印所有逆序 对

```java
public class InversionPair {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("请输入数组个数:");
        int n = scanner.nextInt();

        System.out.println("请输入数组的数:");
        int[] in = new int[n];
        for (int i = 0; i < n; ++i) {
            in[i] = scanner.nextInt();
        }

        int count = process(in, 0, in.length - 1);

        System.out.println(count);
    }

    public static int process(int[] in, int l, int r) {
        if (l == r) {
            return 0;
        }

        int mid = l + ((r -l) >> 1);

        return process(in, l, mid) + process(in, mid + 1, r) + merge(in, l, mid, r);
    }

    public static int merge(int[] in, int l, int mid, int r) {
        int count = 0;

        int[] help = new int[r - l + 1];

        int cur = 0, i = l, j = mid + 1;

        while (i <= mid && j <= r) {
            if (in[i] < in[j]) {
                help[cur++] = in[j++];
            } else {
                count += (r - j + 1);
                help[cur++] = in[i++];
            }
        }

        while (i <= mid) {
            help[cur++] = in[i++];
        }

        while (j <= r) {
            help[cur++] = in[j++];
        }

        for (int k = 0; k < help.length; ++k) {
            in[l + k] = help[k];
        }

        return count;
    }
}
```

# 法国国旗问题

* 问题一

  给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)

  ```java
  public class TheFrenchFlag1 {
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
  
          System.out.println("请输入数组长度：");
          int length = scanner.nextInt();
  
          int[] arr = new int[length];
          System.out.println("请输入数组中的内容：");
          for (int i = 0; i < length; ++i) {
              arr[i] = scanner.nextInt();
          }
  
          System.out.println("请输入目标数字：");
          int target = scanner.nextInt();
  
          fun(arr, target);
  
          for (int num : arr) {
              System.out.print(num + " ");
          }
      }
  
      public static void fun(int[] arr, int num) {
          int l = 0, index = -1;
  
          while (l < arr.length) {
              if (arr[l] <= num) {
                  swap(arr, l++, ++index);
              } else {
                  l++;
              }
          }
      }
  
      public static void swap(int[] arr, int l, int r) {
          int temp = arr[l];
          arr[l] = arr[r];
          arr[r] = temp;
      }
  }
  ```

* 问题二

  给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的 右边。要求额外空间复杂度O(1)，时间复杂度O(N)
  
  ```java
  public class TheFrenchFlag2 {
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
  
          System.out.println("请输入数组长度：");
          int length = scanner.nextInt();
  
          int[] arr = new int[length];
          System.out.println("请输入数组中的内容：");
          for (int i = 0; i < length; ++i) {
              arr[i] = scanner.nextInt();
          }
  
          System.out.println("请输入目标数字：");
          int target = scanner.nextInt();
  
          fun(arr, target);
  
          for (int num : arr) {
              System.out.print(num + " ");
          }
      }
  
      public static void fun(int[] arr, int num) {
          int l = 0, r = arr.length - 1, index = 0;
  
          while (index < arr.length) {
              if (arr[index] < num) {
                  swap(arr, index++, l++);
              } else if (arr[l] == num) {
                  index++;
              } else {
                  swap(arr, index, r--);
              }
          }
      }
  
      public static void swap(int[] arr, int l, int r) {
          int temp = arr[l];
          arr[l] = arr[r];
          arr[r] = temp;
      }
  }
  ```

# 快速排序

* 快排1.0

  1）把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成两个个部分： 左侧<=划分值、右侧>划分值 ，将最后一个数换到，大于区域的最左边变换

  2）对左侧范围和右侧范围，递归执行

  ```java
  public class QuickSort {
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
  
          System.out.println("请输入数组长度：");
          int length = scanner.nextInt();
  
          int[] arr = new int[length];
          System.out.println("请输入数组中的内容：");
          for (int i = 0; i < length; ++i) {
              arr[i] = scanner.nextInt();
          }
  
          fun(arr, 0, length - 1);
  
          for (int num : arr) {
              System.out.print(num + " ");
          }
      }
  
      public static void fun(int[] arr, int l, int r) {
          if (l == r) {
              return ;
          }
  
          int index = l;
  
          while (index < r) {
              if (arr[index] <= arr[r]) {
                  swap(arr, l++, index++);
              } else {
                  index++;
              }
          }
          swap(arr, r, l);
  
          fun(arr, 0, l - 1);
          fun(arr, l, r);
      }
  
      public static void swap(int[] arr, int l, int r) {
          int temp = arr[l];
          arr[l] = arr[r];
          arr[r] = temp;
      }
  }
  ```

* 快排2.0

  1）把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部分： 左侧<划分值、中间==划分值、右侧>划分值 

  2）对左侧范围和右侧范围，递归执行

  **分析**

  1）划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低

  2）可以轻而易举的举出最差的例子，所以不改进的快速排序时间复杂度为O(N^2)

  ```java
  public class QuickSort2 {
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
  
          System.out.println("请输入数组长度：");
          int length = scanner.nextInt();
  
          int[] arr = new int[length];
          System.out.println("请输入数组中的内容：");
          for (int i = 0; i < length; ++i) {
              arr[i] = scanner.nextInt();
          }
  
          fun(arr, 0, length - 1);
  
          for (int num : arr) {
              System.out.print(num + " ");
          }
      }
  
      public static void fun(int[] arr, int l, int r) {
          if (l == r) {
              return ;
          }
  
          int target = arr[r];
          int index = l;
  
          while (index < arr.length) {
              if (arr[index] < target) {
                  swap(arr, l++, index++);
              } else if (arr[index] < target) {
                  swap(arr, r--, index);
              } else {
                  index++;
              }
          }
          swap(arr, arr.length - 1, l);
  
          fun(arr, 0, l - 1);
          fun(arr, r + 1, arr.length - 1);
      }
  
      public static void swap(int[] arr, int l, int r) {
          int temp = arr[l];
          arr[l] = arr[r];
          arr[r] = temp;
      }
  }
  ```

* 快排3.0

  1）在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部分： 左侧<划分值、中间==划分值、右侧>划分值 

  2）对左侧范围和右侧范围，递归执行 

  3）时间复杂度为O(N*logN)
  
  ```java
  public class QuickSort2 {
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
  
          System.out.println("请输入数组长度：");
          int length = scanner.nextInt();
  
          int[] arr = new int[length];
          System.out.println("请输入数组中的内容：");
          for (int i = 0; i < length; ++i) {
              arr[i] = scanner.nextInt();
          }
  
          fun(arr, 0, length - 1);
  
          for (int num : arr) {
              System.out.print(num + " ");
          }
      }
  
      public static void fun(int[] arr, int l, int r) {
          if (l == r) {
              return ;
          }
          int t = l + (int)(Math.random() * (r - l + 1));
          swap(arr, t,  r);
          int target = arr[r];
          int index = l;
  
          while (index < arr.length) {
              if (arr[index] < target) {
                  swap(arr, l++, index++);
              } else if (arr[index] < target) {
                  swap(arr, r--, index);
              } else {
                  index++;
              }
          }
          swap(arr, arr.length - 1, l);
  
          fun(arr, 0, l - 1);
          fun(arr, r + 1, arr.length - 1);
      }
  
      public static void swap(int[] arr, int l, int r) {
          int temp = arr[l];
          arr[l] = arr[r];
          arr[r] = temp;
      }
  }
  ```
  

# 堆

1，堆结构就是用数组实现的完全二叉树结构 

2，完全二叉树中如果每棵子树的最大值都在顶部就是大根堆

3，完全二叉树中如果每棵子树的最小值都在顶部就是小根堆

4，堆结构的heapInsert与heapify操作 

5，堆结构的增大和减少 

6，优先级队列结构，就是堆结构

```java
private static void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    private static void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;

        while (left < heapSize) {
            int large = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            large = arr[large] > arr[index] ? large : index;

            if (large == index) {
                break;
            }

            swap(arr, large, index);
            index = large;
            left = index * 2 + 1;
        }
    }
```

# 堆排序

1，先让整个数组都变成大根堆结构，建立堆的过程: 

1)从上到下的方法，时间复杂度为O(N*logN) 

2)从下到上的方法，时间复杂度为O(N) 

*2，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN) 

3，堆的大小减小成0之后，排序完成

```java
public class HeapSort {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("请输入数组长度：");
        int length = scanner.nextInt();

        int[] arr = new int[length];
        System.out.println("请输入数组中的内容：");
        for (int i = 0; i < length; ++i) {
            arr[i] = scanner.nextInt();
        }

        fun(arr);

        for (int num : arr) {
            System.out.print(num + " ");
        }
    }

    private static void fun(int[] arr) {
        if (arr == null || arr.length < 2) {
            return ;
        }

        for (int i = 0; i < arr.length; ++i) {
            heapInsert(arr, i);
        }
        int heapSize = arr.length;

        swap(arr, 0, --heapSize);

        while (heapSize > 0) {
            heapify(arr, 0, heapSize);
            swap(arr, 0, --heapSize);
        }
    }

    private static void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    private static void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;

        while (left < heapSize) {
            int large = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            large = arr[large] > arr[index] ? large : index;

            if (large == index) {
                break;
            }

            swap(arr, large, index);
            index = large;
            left = index * 2 + 1;
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

