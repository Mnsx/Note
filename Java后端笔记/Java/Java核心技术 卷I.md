# Java的基本程序设计结构

## 简单的Java应用程序

* Java区分大小写
* 类名是以大写字母开头的名词。如果名字由多个单词组成，每个单词的第一个字母都应该大写（这种在一个单词中使用大写字母的方式称为驼峰命名法）
* 在Java中，每个句子必须用分号结束。回车不是语句的结束标志，因此，如果需要可以将一条语句写在多行中
* Java中的方法可以没有参数，也可以有一个或多个参数。即使一个方法没有参数，也需要使用空括号

## 注释

* 最常用的方式是是哟哪个//，其注释内容从//开始到本行结束
* 当需要更长的注释时，既可以在每行的注释前面标记//，也可以使用/\*和/\*注释界定符讲一段比较长的注释括起来
* 第三种注释可以用来自动地生成文档。这种注释以/\**开始，以\*/结束

## 数据类型

Java是一种强类型语言。必须为每一个变量声明一种类型。

### 整型

* 整型用于表示没有小数部分的数值，允许是负数

  | 类型  | 存储需求 | 取值范围                                           |
  | ----- | -------- | -------------------------------------------------- |
  | int   | 4字节    | -2147483648 - 2147483647（10位）                   |
  | short | 2字节    | -32768 - 32767（5位）                              |
  | long  | 8字节    | -9223372036854775808 - 9223372036854775807（20位） |
  | byte  | 1字节    | -128-127（3位）                                    |

* 长整型数值有一个后缀L或l，十六进制数值有一个前缀0x或0X，八进制有一个前缀0，二进制加上前缀0b或0B

* 数值中间可以加上下划线，这些下划线只是为了让人更易读。Java编译器会去除这些下划线

### 浮点类型

* 浮点类型用于表示有小鼠部分的数值

  | 类型   | 存储需求 | 取值范围      |
  | ------ | -------- | ------------- |
  | float  | 4字节    | 有效位数6-7位 |
  | double | 8字节    | 有效位数15位  |

* double表示这种类型的数值精度是float类型的两倍

* 实际上，只有很少的情况适合使用float类型

* float类型的数值有一个后缀F或f，没有后缀默认就是double类型

* 常量表示特殊浮点类型

  * Double.POSITIVE_INFINITY					正无穷大
  * Double.NEGATIVE_INFINITY                  负无穷大
  * Double.NaN                                             NaN（不是一个数字）

### char类型

* char类型原本用于表示单个字符

* 有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值

  | 转义序列 | 名称   | Unicode值 |
  | -------- | ------ | --------- |
  | \b       | 退格   | \u0008    |
  | \t       | 制表   | \u0009    |
  | \n       | 换行   | \u000a    |
  | \r       | 回车   | \u000d    |
  | \\"      | 双引号 | \u0022    |
  | \\'      | 单引号 | \u0027    |
  | \\\      | 反斜杠 | \u005c    |

* 强雷额建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理

### boolean类型

boolean类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换

## 变量和常量

* 声明一个变量后，必须用复制语句对便令进行显示初始化，千万不要使用未初始化的变量值

* 在java中使用关键字final指示常量

* 关键字final表示这个变量只能被赋值一次，一旦被赋值之后，就不能够在更改了

* 常量名使用全大写

* 在Java中经常希望某个常量可以在一个类的多个方法中使用，通常将这些常量称为类常量。可以使用static final设置一个类常量

* 可以自定义枚举类型，枚举类型包括有限个命名的值

  `enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE}`

## 运算符

### 算术运算符

* 使用算术运算符+、-、\*、/表示加减乘除运算。整数的求余操作用%表示
* 整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN

### 数学函数和常量

* 在Math类中，包含了各种各样的数学函数

* 计算一个数值的平方根

  `Math.sqrt(x)`

* 幂运算

  `Math.pow(x, a)`

* floorMode方法的目的是解决一个长期存在的有关整数余数的问题

  如果n是偶数，这个表达式为0

  如果n是奇数，这个表达式为1

  如果n是负数，这个表达式为-1

* Math提供了一些常用的三角函数

  `Math.sin`

  `Math.cos`

  `Math.tan`

  `Math.atan`

  `Math.atan2`

* 指数函数以及它的反函数——自然对数以及以10为底的对数

  `Math.exp`

  `Math.log`

  `Math.log10`

* Java提供两个用于表示Π、e常量的最接近的近似值

  `Math.PI`

  `Math.E`

### 数值类型之间的转换

![](D:\WorkSpace\Note\Java后端笔记\Java\数值类型之间的合法转换.jpg)

* 图中6个实线箭头，表示无信息丢失的转换

  另外三个虚线箭头，表示可能有精度损失的转换

* 当用一个二元运算符连接两个值时，先要将两个操作数转换为同一类型，然后再进行计算
  * 如果两个操作数中有一个double类型，另一个操作数就会转换成double类型
  * 否则，如果其中一个操作数是float类型，另一个操作数将会转换成float类型
  * 否则，如果其中一个操作数是long类型，另一个操作数就会转换成long类型
  * 否则，两个操作数都将被转换成int类型

### 强制类型转换

* 这种可能损失信息的转换要通过强制类型转换来完成，强制类型转换的语法格式是再圆括号中给出想要转换的目标类型，后面紧跟待转换的变量
* 如果想要对浮点数进行舍入运算，以便得到最接近的整数，那就可以使用Math.round()方法，其返回值类型为long，通过强制类型转换，将long型转换为int类型

## 结合赋值和运算符

* 可以在赋值中使用二元运算符，只是一种很方便的简写形式+=、\*=、/=...

### 自增和自减运算符

* 前缀形式会先完成加1，而后缀形式会使用变量原来的值
* 建议不要在表达式中使用++，因为这样的代码很容易让人困惑，而且会带来烦人的bug

### 关系和boolean运算符

* ==、!=、<、>、<=、>=

* &&表达式已经计算得到第一个表达式的真值为false，那么结果就不可能为true
* ||表达式第一个表达式为true时，那么结果的值就自动为true
* 三元表达式?:，这个操作符有时很有用，如果条件为true，就为第一个表达式的值，否则计算为第二个表达式的值

### 位运算符

* |、&、^、~、>>、<<、>>>（最高位用0填充）

### 括号与运算符级别

* 如果不适用圆括号，就按照给出的元素安抚优先级次序进行计算。

* 同一级别的运算符按照从左到右的次序进行计算（有i金额和运算符除外）

  | 运算符                                                       | 结核性   |
  | ------------------------------------------------------------ | -------- |
  | [] . ()（方法调用）                                          | 从左向右 |
  | ! ~ ++ -- +（一元运算符） -（一元运算符） ()（强制类型转换） new | 从右向左 |
  | \* / %                                                       | 从左向右 |
  | + -                                                          | 从左向右 |
  | << >> >>>                                                    | 从左向右 |
  | == !=                                                        | 从左向右 |
  | &                                                            | 从左向右 |
  | ^                                                            | 从左向右 |
  | \|                                                           | 从左向右 |
  | &&                                                           | 从左向右 |
  | \|\|                                                         | 从左向右 |
  | ?:                                                           | 从右向左 |
  | = += -= \*= /= %=  \|= ^= <<= >>= >>>=                       | 从右向左 |

## 字符串

* 从概念上看，Java字符串就是Unicode字符序列

### 子串

* String类的substring方法可以从一个较大的字符串提取出一个子串
* substring方法的第二个参数时不想复制的第一个位置
* substring工作方式有一个优点：容易计算子串的长度

### 拼接

* Java语言允许使用+号连接两个字符串

* 当将一个字符串与一个非字符串的值进行拼接时，后者会转换成字符串

* 如果需要把多个字符串放在一起，用一个界定符分隔，可以使用静态join方法

  `String all = String.join("/", "S", "M", "L", "XL"); //"S/M/L/XL"`

* >java11中提供了repeat方法：
  >
  >`String repeated = "Java".repeat(3); //"JavaJavaJava"`

### 不可变字符串

* String类没有提供修改字符串某个字符的方法
* 由于不能修改Java字符串中的单个字符，所以在Java文档中加功能String类对象称为不可变的
* 字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制字符串共享相同的字符

### 检测字符串是否相等

* 可以使用equals方法检测两个字符串是否相等
* 如果字符串s与字符串t相等，则返回true；否则返回false
* 想要检测两个字符串是否相等，而不去分大小写，可以使用equalsIgnoreCase方法
* ==运算符只能够确定两个字符串是否存放在同一位置
* 实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享

### 空串和Null串

* 空串“”是长度为0的字符串，空串是一个Java对象，有自己的串长度和内容
* String变量还可以存放一个特殊的值，名为null，表示目前没有任何对象与该变量关联

### 构建字符串

* 使用StringBuilder类可以构建一个新的String对象，相较于拼接字符串时，既省时，又节省空间
* 在字符串构建完成时就调用toString方法，将可以得到一个String对象，其中包含了构建器中的字符序列

## 输入与输出

 ### 读取输入

* 想要通过控制台进行输入，首先需要构造一个与“结构输入流”System.in关联的Scanner对象
* 使用nextLine方法时可以读取一行输入
* 使用nextLine方法时因为输入行中有可能包含空格，想要读取一个单词可以调用next方法
* 整型可以使用nextInt，浮点型可以使用nextDouble

### 格式化输出

* System.out.println()

* System.out.print()

* System.out.printf()

  | 转换符 | 类型                           | 实例     |
  | ------ | ------------------------------ | -------- |
  | d      | 十进制整数                     | 159      |
  | x      | 十六进制整数                   | 9f       |
  | o      | 八进制整数                     | 237      |
  | f      | 定点浮点数                     | 15.9     |
  | e      | 指数浮点数                     | 1.59e+01 |
  | g      | 通用浮点数（e和f中较短的一个） | ——       |
  | a      | 十六进制浮点数                 | 01.ccdp3 |
  | s      | 字符串                         | Hello    |
  | c      | 字符                           | H        |
  | b      | 布尔                           | true     |
  | h      | 散列码                         | 42628b2  |
  | tx或Tx | 日期时间（T强制大写）          | 已经过时 |
  | %      | 百分号                         | %        |
  | n      | 与平台有段的行分割符           | ——       |

  | 标志              | 目的                   | 实例         |
  | ----------------- | ---------------------- | ------------ |
  | +                 | 打印正数和负数的符号   | +3333.33     |
  | 空格              | 在正数之前添加空格     | \| 3333.33\| |
  | 0                 | 数字前面补0            | 003333.33    |
  | -                 | 左对齐                 | \|3333.33 \| |
  | (                 | 将符号括在括号内       | （3333.33）  |
  | ,                 | 添加分组分隔符         | 3,333.33     |
  | #（对于f格式）    | 包含小数点             | 3,333.       |
  | #（对于x或0格式） | 添加前缀0x或0          | 0xcafe       |
  | $                 | 指定要格式化的参数索引 | 159 9F       |
  | <                 | 格式化前面说明的数值   | 159 9F       |

* 可以使用静态String.format方法的创建一个格式化的字符串，而不打印输出

### 文件输入与输出

* 读取一个文件，需要构造一个Scanner对象

  `Scanner in = new Scanner(Path.of("myfile.txt"), StandardCharset.UTF_8)`

* 写入文件需要构造一个PrintWriter对象

  `PrintWriter out = new PrintWriter("myfile.txt", StandardCharsets.UTF_8)`

## 控制流程

### 块作用域

* 块是指由若干条Java语句组成的语句，并用一对大括号括起来。块确定了变量的作用域了。一个块可以嵌套在另一个块中
* 但是，不能在嵌套的两个块中声明同名的变量

### 条件语句

```java
if (condition) {
	statement;
}

if (condition) {
    statement1;
} else {
    statement2;
}

if (condition1) {
    statement1;
} else if (condition2) {
    statement2;
} else {
    statement3;
}
```

### 循环

```java
while (condition) {
    statement;
}

do {
    statement;
} while (condition);

for (int i = 0; i < length; ++i) {
    statement;
}
```

### 多重选择：switch语句

```java
switch (choice) {
    case 1:
        statement;
        break;
    case 2:
        statement;
        break;
    case 3:
        statement;
        break;
    default:
        statement;
        break;
}
```

* switch语句将从与选项值像匹配的case标签开始执行，直到遇到break语句，或者执行到switch语句的结束处为止
* 如果没有相匹配的case标签，而有default子句，就执行这个子句
* case标签可以是：
  * 类型为char、byte、short或int的常量表达式
  * 枚举常量
  * 字符串字面量

### 中断控制流程的语句

> goto不建议使用

## 大数

* 如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中两个很有用的类：BigInteger和BigDecimal

* 这两个类可以处理包含任意长度数字序列的数值

* 使用静态的valueOf方法可以将普通的数值转换为大数

  `BigInteger a = BigIntetger.valueOf(100)`

* 对于更大的数，可以使用一个带字符串参数的构造器

  `BigInteger b = new BigInteger("22222222222222")`

* 大数常量：BigInteger.ZERO、BigInteger.ONE、BigInteger.TEN

  > Java9中添加了BigInteger.TWO

* 大数中没有算术运算符处理大数，需要使用大数类中的add和multiply方法

## 数组

### 声明数组

* 数组是一种数据类型，用来存储同一类型值得集合。通过一个整型下标可以访问数组中得每一个值

* 声明了变量后需要初始化才能使用，使用new操作符创建数组

* 一旦创建了数组，就不能改变它得长度

* Java中还提供了一种创建数组对象并且提供初始值得简写形式

  `int[] arr = {2, 3, 5}`

### 访问数组元素

* 创建一个数字数组时，所有元素都初始化为0，boolean数组得元素初始化为false，对象数组得元素初始化为一个null值，表示这些元素为存放任何对象
* 通过arr.length可以获取数组中得元素个数

### for each循环

`for (variable : collection) statement`

collection这一集合表达式必须是一个数组或者是一个实现了iterable接口得类对象

### 数组拷贝

* 在java中，允许将一个数组变量拷贝到另一个数组变量。两个变量将引用同一个数组

* 可以使用Arrays.copyOf方法将一个数组地所有值拷贝到一个新的数组中

  `int[] copyArr = Arrays.copyOf(arr, arr.length)`

  第二个参数是新数组地长度，**这个方法通过用来增加数组的大小**

### 数组排序

* 通过Arrays.sort(int[] arr)将数组进行排序
* 这个方法使用了优化的快速排序

### 多维数组

* 多维数组将使用多个下标访问数组元素，它适用于表示表格或者更加复杂的排序形式

# 对象与类

## 面向对象程序设计概述

### 类

* 类是构造对象的模板或蓝图
* 由类构造对象的过程称为创建类的实例
* 封装就是将数据和行为组成在一个包中，并对对象的使用者隐藏具体的实现方式
* 对象中的数据称为实例字段，操作数据的过程称为方法
* 所有其他类都扩展自Object类
* 扩展后的心累具有被扩展类的全部属性和方法
* 面向对象三大特征
  * 对象的行为
  * 对象的状态
  * 对象的标识

### 类之间的关系

* 类中常见的关系
  * 依赖——如果一个类的方法使用或操作另一个类的对象，我们就说一个类依赖另一个类
  * 聚合——类A对象包含类B对象
  * 继承——如果类A扩展类B，类A不但包含从类B继承的方法，还会有一些额外的功能
* 我们应该尽可能地将相互依赖地类减至最少，尽可能减少类之间的耦合

## 使用预定义类

### 对象与对象变量

* 要想使用对象，首先必须构造对象，并指定其初始状态
* 构造器是一种特殊的方法，用来构造并初始化对象
* 构造器的名字应该与类名相同
* 对象变量并没有实际包含一个对象，它只是引用一个对象

### LocalDate类

* 不要使用构造器来构造LocalDate类的对象，实际上应当使用静态工厂方法，它会代表你调用构造器

  `LocalDate.now()`

* 可以提供年、月和日来构造对应一个特定日期的对象

  `LocalDate.of(1999, 12, 31)`

* 一旦有一个LocalDate对象，可以用方法`getYear`、`getMonthValue`、`getDayOfMonth`得到年月日

### 更改器方法和访问器方法

* 调用更改器方法后，对象的状态会发生改变
* 只访问对象而不修改对象的方法有时称为访问器方法

## 用户自定义类

* 构造器和其他方法有一个重要的不同，构造器总是结合new运算符来调用，不能对一个已经存在的对象调用构造器来达到重新设置实例字段的目的
  * 构造器与类同名
  * 每个类可以有一个以上的构造器
  * 构造器可以有0个、1个或多个参数
  * 构造器没有返回值
  * 构造器总是伴随着new操作符一起调用

> * 在Java10中，如果可以从变量的初始值推到出它们的类型，那么可以用var关键字声明局部变量，而无需指定类型，那么可以用var关机子声明局部变量，而无需指定类型
> * var关键字只能用于方法中局部变量，参数和字段的类型必须声明

* 对null值应用一个方法，就会产生一个NullPointException异常

> * Java9中，Object类对此提供了一个方法Object.requireNonNullElse(n, "xxx")

* 如果需要获得或设置实例字段的值，那么需要提供三个内容：
  * 一个私有的数据字段
  * 一个公共的字段访问器方法
  * 一个公共的字段更改器方法
* 在实现一个类时，由于公共数据非常危险，所以应该将所有的数据字段都设置为私有的
* 将实例字段定义为final，这样的字段给必须在构造对象时初始化，必须确保在每一个构造器执行之后，这个字段的值已经设置，并且以后不能再修改这个字段

## 静态字段和静态方法

### 静态字段

* 设置了static修饰符之后，这个属性或者方法就属于类而不是属于任何单个的对象

### 静态常量

* 声明变量时，添加final、static

### 静态方法

* 静态方法是不在对象上执行的方法
* 方法不需要访问对象状态时，因为它需要的所有参数都通过显示参数提供
* 方法只需要访问类的静态字段

### 工厂方法

* 静态方法还有另一个常用的用途，使用静态工厂方法来构造对象
* 不适用构造器而使用工厂方法的原因：
  * 无法命名构造器。构造器的名字必须与类名相同
  * 使用构造器时，无法改变所构造对象的类型。

### main方法

* main方法不对任何对象进行操作

## 方法参数

* 按值调用表示方法接收的是调用者提供的值，而按需调用表示方法接收的是调用者提供的变量地址
* 方法可以修改按需调用的值，但是不能修改按值调用的值
* 对象引用是按值传递的
  * 方法不能修改基本数据类型的参数
  * 方法可以改变对象参数的状态
  * 方法不能让一个对象参数引用一个新的对象

## 对象构造

### 重载

* 如果多个方法有相同的名字、不同的参数，便出现了重载
* 它用各个方法首部中参数类型与特定方法调用中所使用的值类型进行匹配，来选出正确的方法

### 无参数的构造器

* 如果写一个类时没有编写构造器，就会为你提供一个无参构造器，这个构造器将所有的实例字段设置为默认值
* 如果类中提供了至少一个构造器，但是没有提供无参数的构造器，那么构造对象时如果不提供参数就是不合法的

### 调用另一个构造器

* 通过this方法调用另一个构造器

### 初始化块

* 三种初始化数据字段的方法
  * 在构造器中设置值
  * 在声明中赋值
  * 初始化块
* 只要构造这个类的对象，这些块就会被执行
* 首先运行初始化块，然后才运行构造器的主体部分
* 调用构造器的具体处理步骤
  * 如果构造器的第一行调用了另外的一个构造器，则基于所提供的参数值执行第二个构造器
  * 否则
    * 所有数据字段初始化为其默认值（0、false、null）
    * 按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块
  * 执行构造器主体代码
* 如果类的静态字段需要很复杂的初始化代码，那么可以使用静态初始化块
* 在类第一次加载的时候将会进行静态字段的初始化
* 所有静态字段初始化方法以及静态初始化块都依照类声明中出现的顺序执行

### 对象析构与finalize方法

* java会完成自动的垃圾回收，不需要人工回收内存，所以Java不支持析构器

> java9中，可以使用Cleaner类注册一个动作，当对象不在可达时，就会完成这个动作

* 不要使用finalize方法来完成清理。这个方法原本要在垃圾回收器清理对象之前调用
* 文件或者使用了系统资源的另一个对象的句柄，这种情况下，当资源不再需要时，俺么应当提供一个close方法来完成必要的清理工作

## 包

### 包名

* 为了保证包名的绝对唯一性，要勇于给因特网域名（这显然是唯一的）以逆序的形式作为包名，然而对于不同的工程使用不同的子包

### 类的导入

* 一个类可以使用所属包中的所有类，以及其他包中的公共类
* 使用完全限定名：就是包名后面跟着类名
* 使用import语句，一但使用了import语句，在使用类时，就不必写出类的全名
* 可以使用`import java.time.*`导入java.time包中的所有类

### 静态导入

* import语句允许导入静态方法和静态字段

  `import static java.lang.System.*`

  这样就可以使用System类的静态方法和静态字段，而不必加类名前缀

### 在包中增加类

* 在代码最开头加上package语句，代表向这个包中添加一个类

* 如果没有在源文件中放置package语句，这个源文件中的类就属于无名包

## 包访问

* 如果没有添加修饰符，这个部分可以被统一包中的所有方法访问

### 类路径

* 类路径（classpath），类路径是所有包类文件的路径的集合

### 设置类路径

* 最好使用-classpath选项指定类路径

## JAR文件

* 在将应用程序打包时，你一定希望只想用户提供一个单独的文件，而不是一个包含大量类文件的目录结构，java归档文件就是为此目的为设计的

* 创建一个新JAR文件最常用的命令

  `jar cvf jarFileName file1 file2`

  | 选项 | 说明                                                         |
  | ---- | ------------------------------------------------------------ |
  | c    | 创建一个新的或者空的存档文件并加入文件，如果指定的文件名时目录，jar程序将会对他们进行递归处理 |
  | C    | 临时改变目录切换到classes子目录以便增加类文件                |
  | e    | 在清单文件中创建一个入口点                                   |
  | f    | 指定jar文件名作为第二个命令行参数。如果没有这个参数，jar命令将结果写至标准输出或者从标准输入读取 |
  | i    | 建立索引文件                                                 |
  | m    | 将一个清单文件添加到JAR文件中，清单是对归档内容和来源的一个说明。每个归档有一个默认的清单文件。但是，如果像验证归档文件的内容，可以提供自己的清单文件 |
  | t    | 显示内容表                                                   |
  | u    | 更新一个已有的JAR文件                                        |
  | v    | 生成详细的输出结果                                           |
  | x    | 解压文件。如果提供一个或多个文件名，只解压这些文件；否则，解压所有文件 |
  | 0    | 存储，但不进行ZIP压缩                                        |

## 文档注释

### 注释的插入

* javadoc实用工具从下面几项中抽取信息
  * 模块
  * 包
  * 公共类和接口
  * 公共的和受保护的字段
  * 公共的和受保护的构造器及方法

### 方法注释

* @param variable descriptioon

  这个标记将给当前方法的”paramters“部分添加一个条目

* @return description

  这个标记将给当前方法添加”return是“部分

* @throws class description

  这个标记将添加一个注释，表示这个方法有可能抛出异常

### 通用注释

* @author name

  这个标记将会产生一个author条目

* @version text

  这个标记将会产生一个version条目

* @since text

  会建立一个since条目

* @see 和 @link标记，可以使用超链接

## 类设计技巧

* 一定要保证数据私有
* 一定要对数据进行初始化
* 不要在类中使用过多的基本类型
* 不是所有的字段都需要单独的字段访问器和字段更新器
* 分解有过多职责的类
* 类名分方法名要能够体现他们的职责
* 优先使用不可变的类

# 继承

* 继承的基本思想是，可以基于已有的类创建新的类，继承已存在的类就是复用这些类的方法，而且可以增加一些新的方法和字段，是新类能够适应新的情况

## 类、超类、子类

### 定义子类

* 关键字extends表明正在构造的新类派生于一个已存在的类，新类称为子类，已存在的类称为父类
* 通过扩展超类定义子类时，只需要指出子类和超类的不同之处

### 覆盖方法

* 当父类中的方法在子类中并不适用时，需要提供一个新的方法来**覆盖**超类中的这个方法
* 只有父类能够访问父类的私有字段，子类无法访问父类的私有字段
* super关键字代表父类对象，可以通过super来调用父类的方法和构造器

### 子类构造器

* 语句`super(xxx)`时调用超类中的构造器的意思
* 因为子类无法访问父类的私有字段，所以需要通过构造器方法来初始化这些私有字段
* 使用super调用构造器的语句必须是子类构造器的第一条语句
* 如果子类构造器没有显式调用超类的构造器，将自动地调用超类的无参构造器
* 如果超类没有无参数的构造器，并且在子类的构造器中有没有显式地调用超类的其他构造器，Java编译器就会报告一个错误
* 一个变量可以只是多种实际类型的现象称为多态
* 在运行时能够自动地选择适当的方法，称为动态绑定

### 继承层次

* 由一个公共超类派生出来的所有类的集合称为继承层次
* 在继承层次中，从某个特定的类到其祖先的路径称为该类的继承链

### 多态

* 判断是否应该将数据设计为继承关系，可以通过”is-a“规则，也成为替换原则，他指出程序中出现超类对象的任何地方都可以使用子类对象替换
* 不能将超类引用赋给子类变量

### 理解方法调用

* 编译器查看对象声明类型和方法名，编译器将会一一列举该类中所有对应名称的方法和其超类中所有对应名称的而且可以访问的方法
* 编译器要确定方法调用中提供的参数类型，如果方法中存在一个于所提供参数类型完全匹配的方法，就选择这个方法，这个过程称为重载解析
* 如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地直到应该调用哪个方法，这称为静态绑定
* 程序运行别切采用动态绑定调用方法，虚拟机必须调用于指定类所引用的对象的实际类型相对应的哪个方法
* 每次调用方法都需要搜索时间开销相当大，所以虚拟机会预先为每个类计算一个方法表，其中列出了所有的方法的签名发和要调用的实际方法

### 阻止继承：final类和方法

* 不允许扩展的类别成为final类，如果在定义类的时候使用了final修饰符就表明这个类是final类
* 类中的某个特定方法也可以声明为final，这样，子类就不能覆盖这个方法
* 将方法或类声明为final的主要原因是：确保它们不会再子类中改变语义

### 强制类型转换

* 进行强制类型转换的唯一原因是：要在暂时护士对象的实际类型之后使用对象的全部功能
* 在进行强制类型转换之前，先查看是否能够成功地转换，为此需要使用instanceof操作符就可以实现
* 只能在继承层次内进行强制类型转换
* 在将超类强制转换成子类之前，应该使用instanceof进行检查

### 抽象类

* 对方法使用了abstract修饰符，就可以安全不需要实现这个方法
* 为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象
* 除了抽象方法之前，抽象类还可以包含字段和具体方法
* 扩展抽象类有两种方法：
  * 在子类中保留抽象类中的部分或所有抽象方法任未定义，这样必须将子类也标记为抽象类
  * 定义全部方法，子类就不再是抽象方法
* 即使不含抽象方法，也可以将类声明为抽象方法
* 抽象类不能实例化，如果将一个类声明为abstract，就不能创建这个类的对象
* 可以定义一个抽象类的对象变量，但这样一个变量只能引用非抽象子类的对象

### 受保护访问

* 设置受保护（protected）修饰类方法和字段，这样可以限制超类的某个方法只允许子类访问
* 访问控制修饰符总结：
  * 仅对本类可见——private
  * 对外部完全可见——public
  * 对本包和所有子类可见——protected
  * 对本包可见——默认，不需要修饰符

## Object：所有类的超类

* Object类是java中所有类的始祖，在java中每个类都扩展了Object

### Object类型变量

* 可以使用Object类型的变量引用任何类型的对象

### equals方法

* Object类中的equals方法用于检测一个对象是否等于另外一个对象，Object类中是心啊的equals方法将确定两个对象的引用是否相等

### 相等测试和继承

* Java语言规范要求equals方法具有下面的特性

  * 自反性：对于任何非空引用x，x.equals(x)返回true
  * 对称性：对任何引用x和y，当且仅当y.equals(x)返回true时，x.equals(y)返回true
  * 传递性：对于任何引用x，y和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true
  * 一致性：如果x和y引用对象没有发生变化，反复调用x.equals(y)应该返回同样的结果
  * 对任意非空引用x，x.equals(null)应该返回false

* 如果子类可以有自己的相等性概念，则对称性需求将强制使用getClass检测

* 如果由超类决定相等性概念，那么就可以使用instanceof检测，这样可以在不同子类的对象那个之间进行相等性比较

* 编写equals方法的建议：

  * 显示参数命名为otherObject，稍后需要将它强制转换成另一个名为other的变量

  * 检测this与otherObjec是否相等

    `if (this == otherObject) return true`

  * 检测otherObject是否为null，如果为null，返回false

    `if (otherObject == null) return false`

  * 比较this与otherObject类，如果equals的语义可以在子类中改变，基于可以使用getClass检测

    `if (getClass() != otherObject.getClass()) return false`

    如果所有的子类都有相同的相等性语义，可以使用instanceof检测

    `if (!(otherObject instanceof ClassName)) return false`

  * 将otherObject强制装换为相对应类类型的变量

    `ClassName other = (ClassName)otherObject`

  * 现在根据相等性概念的要求来比较字段。使用==比较基本类型字段，使用Object.equals比较对象字段。如果所有的字段都匹配，就返回true，否则返回false

    `return field = ohter.field1 && Object.equals(field2, other.field2) && ....`

### hashCode方法

* 散列码是由对象导出的一个整型值，散列码是没有规律的，如果x和y是两个不同的对象，x.hashCode()与y.hashCode()基本上不会相同
* Object类的默认hashCode方法会从对象的存储地址得出散列码
* 如果重新定义了equals方法，就必须为用户可能插入散列表的对象重新定义hashCode方法

### toString方法

* toString方法，它回安徽白哦是对象值的一个字符串

## 泛型数组列表

### 声明数组列表

* <>称为菱形语法，因为空间括号像个菱形，如果赋值给一个变量，或传递给某个方法，或者从某个方法返回，编译器会检查这个变量、参数或方法的泛型类型，然后将这个类型放在<>中
* 使用add方法可以将元素添加到数组例表中
* 如果调用add而内部数组已经满了，数组列表就会自动地创建一个更大的数组
* 如果已经知道或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法
* 还可以把初始容量传递给ArrayList构造器
* size方法返回数组列表中包含的实际元素个数
* 一旦消减了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该再确认不会再向数组列表添加你家任何元素时再调用trimToSIze

### 访问数组列表元素

* 使用get和set方法访问和修改数组列表中的元素
* 使用toArray方法将数组元素拷贝到一个数组中
* 如果需要再数组列表中间插入元素，可以使用add方法并且提供一个索引参数
* 使用remove删除元素

## 对象包装器和自动装箱

* 所有的基本类都有一个与之对应的包装器类
* 包装器类是不可变的，即一旦构造了包装器，就不再允许更改包装再其中的值了
* 包装器类还是final，因此不能派生它们的子类
* 尖括号中的类型参数不允许是基本类型
* `Integer.valueOf(2)`自动装箱机制
* `obj.intValue()`自动拆箱机制
* 比较两个包装器类不能使用==而使用equals
* 装箱和拆箱是编译器要做的工作而不是虚拟机

## 参数数量可变方法

* 省略号...是Java代码的一部分，它表明这份方法可以接收任意数量的对象

## 枚举类

`public enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE}`

* 比较两个枚举类型的值时，并不需要调用equals，直接使用==就可以了
* 枚举的构造器总是私有的
* toString返回枚举的常量名
* toString方法的逆方法时valueOf
* 每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组

## 反射

* 在运行时分析类的能力
* 在运行时检查对象
* 实现泛型数组操作代码
* 利用Method对象

### Class类

* 在程序运行期间，Java运行时系统始终为所有对象维护一个运行时类型标识。这个信息会跟踪每个对象所属类，虚拟机利用运行时类型信息选择要执行的正确方法
* Object类中的getClass()方法将会返回一个Class类的实例
* Class类的getName方法就返回类的名字
* 还可以使用静态方法forName获取类名对应的class对象
* 如果T是任意的Java类型，T.class将代表匹配的类对象
* 虚拟机为每个类型管理一个唯一的Class对象，因此可以利用==运算符实现两个类对象的比较
* 调用getConstructor方法将会得到一个Constructor类型对象，然后使用newInstance方法来构造一个实例

### 声明异常入门

* 抛出异常比终止程序要灵活的多，这是因为可以提供一个处理器“捕获“这个异常并进行处理
* 异常有两种类型：非检查型异常和检查型异常

### 资源

* Class类提供了一个很有用的服务可以查找资源文件
  * 获得拥有资源的类的class对象
  * 如果有方法接收描述资源位置的URL那么就调用getResource()
  * 否则，使用getResourceAsStream方法得到一个输入流来读取文件中的数据

### 利用反射分析类的能力

* 在java.lang.reflect包中由三个类Field、Method、Constructor分别用于描述类的字段、方法和构造器
* 这三个类都有一个叫做getName的方法，用来返回字段、方法或构造器的名称
* Field类有一个getType方法，用来返回描述字段类型的一个对象，这个对象的类型同样是Class
* Method和Constructor类有报告参数类型的方法
* Method类有一个报告返回类型的方法、
* 这三个类都有一个名为getModifiers的方法，它将返回一个整数，用不同的0/1位描述所使用的修饰符
* 还可以利用Modifier类的静态方法分析getModifiers返回的这个整数（isPublic\isPrivate\ifFinal）
* Modifier.toString能够将修饰符打印出来
* Class类中getFields、getMethods、getConstructors返回这个类支持的公共字段、方法和构造器，包括超类中的所有成员，getDeclareFields、getDeclareMethods、getDeclareConstructor方法将返回类中声明的全部字段、方法和构造器，其中不包括超类

### 利用反射在运行时分析对象

* Field类中的get方法，f.get(obj)将返回一个对象，其值为obj的当前字段值
* 调用f.set(obj, value)把对象obj的f表示的字段设置为新值
* 如果字段为一个私有字段，get和set方法就会抛出IllegalAccessException异常
* 可以调用Field、Method、Constructor对象的setAccessible方法覆盖Java的访问控制

### 使用反射编写泛型数组代码

* Array类的静态方法newInstance，这个方法能够构造一个新数组，调用这个方法时必须提供两个参数，一个是数组的类型，一个是数组的长度

  `Object newArray = Array.newInstance(componentType, newLength)`

* 通过调用Array.getLength(a)获得数组的长度

### 调用任意方法和构造器

* Method方法有一个invoke方法，允许调用包装在当前Method对象中的方法

## 继承的设计技巧

* 将公共操作和字段放在超类中
* 不要使用受保护的字段
* 使用继承实现“is-a“关系
* 除非所有继承的方法都有意义，否则不要使用继承
* 在覆盖方法时，不要改变预期的行为
* 使用多态，而不要使用类型信息
* 不要滥用反射

# 接口、lambda表达式和内部类

## 接口

### 接口的概念

* 在Java程序中，接口不是类，而是对希望复合这个接口的类的一组需求
* 接口中的所有方法都自动是public方法
* 接口不会有实例字段，在Java8之前，接口中不会实现方法
* 让一个类实现一个接口：
  * 将类声明为实现给定的接口
  * 对接口中的所有方法提供定义
* 需要使用关键字implements将类声明为实现某个接口

### 接口的属性

* 接口不是类，不能使用new运算符实例化一个接口，但是可以声明接口的变量，接口的变量必须引用实现了这个接口的类对象
* 可以使用instanceof检查一个对象是否实现了某个特定的接口
* 允许有多条接口链，从通用性较高的接口扩展到专用性较高的接口
* 接口中可以包含常量，接口中的字段总是public static final
* 可以使用逗号将想要实现的各个接口分隔开

### 接口与抽象类

* 每个类只能扩展一个类，但是每个类可以实现多个接口

### 静态和私有方法

* 在java8中，允许在接口中增加静态方法
* 所以，实现自己的接口时，没有必要再为实用工具方法另外提供一个伴随类

> * 在java9中，接口中的方法可以是private，private方法可以是静态方法或实例方法，由于私有方法只能在接口本身的方法中使用，所以它们的用法很有限，只能作为接口中的其他方法的辅助方法

### 默认方法

* 可以为接口方法提供一个默认实现，必须用default修饰符标记这样的一个方法
* 在已经被实现的接口中增加默认方法不会报错
* 可以直接通过接口名加方法名，调用这个方法

### 解决默认方法冲突

* 如果在一个接口中将一个方法定义为默认方法，然后又在超类或者另一个接口中定义了同样的方法：
  * 超类优先，如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略
  *  接口冲突，如果一个接口提供了一个默认方法，另外一个接口提供了一个同名而且参数类型相同的方法，必须覆盖这个方法来解决冲突

### 接口与回调

* 回调是一种常见的程序设计模式，可以指定某个特定事件时应该采取的动作

### Comparator接口

* 对一个对象数组进行排序，前提是这些对象是实现了Comparable接口的类的实例
* Arrays.sort，需要一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例

### 对象克隆

* Cloneable接口，这个接口指示一个类提供了一个安全的clone方法
* 为一个包含对象引用的变量建立副本时，原变量和副本都是同一个对象的引用，任何一个变量改变都会影响另一个变量
* clone方法是Object的一个protected方法，这说明你的代码不能直接调用这个方法
* 默认的克隆操作是”浅拷贝“，并没有克隆对象中引用的其他对象
* 如果源对象和浅克隆对象共享的子对象是不可变的，那么这种共享就是安全的
* 通常子对象都是可变的，必须重新定义clone方法来建立一个深拷贝，同时克隆所有子对象

## lambda表达式

* lambda表达式是一个可传递的代码，可以在以后执行一次或多次

### lambda表达式的语法

* lambda表达式就是一个代码块，以及必须传入代码的变量规范
* 一种lambda表达式形式：参数，箭头（->）以及一个表达式
* 如果代码要完成的计算无法方法在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显式的return语句
* 即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样
* 如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型
* 如果方法只有一个参数，而且这个参数类型可以推导出来，那么甚至可以省略小括号
* 无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出

### 函数式接口

* 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口

### 方法引用

* 方法引用，只是编译器生成一个函数式接口的实例，覆盖这个接口的抽象方法来调用给定的方法
* 要用::运算符分割方法名和对象或类名，主要有3中情况：
  * object::instanceMethod，方法引用等价于想方法传递参数的lambda表达式
  * Class::instanceMethod， 第一个参数会成为方法的隐式参数
  * Class::staticMethod，所有参数都传递到静态方法
* 只有当lambda表达式的体只调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用
* 可以在方法引用中使用this参数，使用super也是合法的

### 构造器的使用

* 构造器引用与方法引用很类似，只不过方法名为new
* Java有一个限制，无法构建泛型类型T的数组

### 变量作用域

* lambda表达式有3个部分

  * 一个代码块
  * 参数
  * 自由变量的值，这是指非参数而且不在代码中定义的变量

* lambda表达式可以捕获外围作用域中变量的值，在lambda表达式中，只能引用值不会改变的变量

* 如果在lambda表达式中更改变量，并发执行多动作时就会不安全

* 如果在lambda表达式中引用一个变量，而这个变量可能在外部改变，这也是不合法的

* lambda表达式中捕获的变量必须实际上是事实最终变量（这个变量初始化之后就不会再为它赋新值）

* 在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的

* 在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数

  > 闭包就是在一个函数中引用了外部的变量，导致该变量不会被GC回收

### 处理lambda表达式

* 使用lambda表达式的重点是延迟执行

* 使用lambda表达式的原因

  * 在一个单独的线程中运行代码
  * 多次运行代码
  * 在算法的适当位置运行代码
  * 发生某种情况时执行代码
  * 只在必要时才运行代码

  | 函数式接口          | 参数类型 | 返回类型 | 抽象方法 | 描述                         | 其他方法                   |
  | ------------------- | -------- | -------- | -------- | ---------------------------- | -------------------------- |
  | Runnable            | 无       | void     | run      | 作为无参数或返回值的动作运行 |                            |
  | Supplier<T>         | 无       | T        | get      | 提供一个T类型的值            |                            |
  | Consumer<T>         | T        | void     | accept   | 处理一个T类型的值            | andThen                    |
  | BiConsumer<T, U>    | T，U     | void     | accept   | 处理T和U类型的值             | andThen                    |
  | Function<T, R>      | T        | R        | apply    | 有一个T类型参数的函数        | compose，andThen，identity |
  | BiFunction<T, U, R> | T，U     | R        | apply    | 有T和U类型参数的函数         | andThen                    |
  | UnaryOperator<T>    | T        | T        | apply    | 类型T上的一元操作符          | compose，andThen，identity |
  | BinaryOperator<T>   | T，T     | T        | apply    | 类型T上的二元操作符          | andThen，maxBy，minBy      |
  | Predicate<T>        | T        | boolean  | test     | 布尔值函数                   | and，or，negate，isEqual   |
  | BiPredicate<T, U>   | T，U     | boolean  | test     | 有两个参数的布尔值函数       | and，or，negate            |

### 再谈Comparator

* Comparator接口包含很多方便的静态方法来创建比较器
* 静态comparing方法去一个”键提取器“函数，它将类型T隐射为一个可比较的类型，对要比较的对象应用这个函数，然后对返回的键完成比较
* 可以把比较器与thenComparing方法串起来，来处理比较结果相同的情况

## 内部类

* 内部类是定义在另一个类中的类
  * 内部类可以对同一个包中的其他类隐藏
  * 内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据

### 使用内部类访问对象状态

* 一个内部类方法可以访问自己的数据字段，也可以访问创建它的外部类对象的数据字段
* 内部类的对象总有一个隐式引用，指向创建它的外部类对象

### 内部类的特殊语法规则

* 在外围类的作用域之外，可以这样引用内部类

  OuterClass.InnerClass

### 内部类是否有用、必要和安全

* 内部类是一个编译器现象，与虚拟机无关
* 编译器将会把内部类转换为常规类文件，用$分隔外部类名与内部类名，而虚拟机对此一无所知
* 编译器会生成一个额外的实例字段this$0，对应外围类引用
* 内部内拥有更大的访问权限，所以太女生就比常规类功能更加强大

### 局部内部类

* 声明局部类时不能有访问说明符，局部类的作用域被限定在声明这个局部类的块中

### 由外部方法访问变量

* 局部类还有一个优点，它们不仅能够访问外部类的字段，还可以访问局部变量，不过局部变量必须时事实最终变量

### 匿名内部类

* 创建这个类的一个对象，甚至不需要为类指定名字，这样一个类被称为匿名内部类
* 由于构造器的名字必须与类名相同，而匿名内部类没有类名，所以，匿名内部类不能有构造器
* 尽管匿名类不能有构造器，但可以提供一个对象初始化块
* 相比于使用内部类，更加好的做法是使用lambda表达式

### 静态内部类

* 使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类有外围类对象的一个引用，为此可以将内部类声明为static
* 只要内部类不需要访问外围类对象，就应该使用静态内部类
* 与常规内部类不同，静态内部类可以有静态字段和方法
* 在接口中声明的内部类自动是static和public

## 代理

### 何时使用代理

* 需要在运行的程序中定义一个新类

* 代理类可以在运行时创建全新的类，这样的代理类能够实现你指定的接口

  * 指定接口所需的全部方法
  * Object类中的全部方法

* 在运行时定义新代码，必须提供一个调用处理器，调用处理器是实现了InvocationHandler接口的类的对象，这个接口只有一个方法

  `Object invoke(Object proxy, Method method, Object[] args)`

* 无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用，并向其传递Method对象和原调用的参数，之后调用处理器必须确定如何处理这个调用

### 创建代理对象

* 想要创建一个代理对象需要使用Proxy类的newProxyInstance方法
  * 一个类加载器
  * 一个Class对象数组，每个元素对应需要实现的各个接口
  * 一个调用处理器

### 代理类的特性

* 代理类是在程序运行过程中创建的
* 一个扩展类只有一个实例字段——即调用处理器
* 所有的代理类都要覆盖Object类的toString、equals和hashCode方法

### 代理实例

动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。

* 接口类

  ```java
  public interface IUserDao {
      public void save();
  }
  ```

* 目标对象

  ```java
  public class UserDao implements IUserDao {
  	@Override
      public void save() {
          System.out.println("...");
      }
  }
  ```

* 动态代理对象

  ```java
  public class UserProxyFactory {
      private Object target;
      
      public ProxyFactory(Object target) {
          this.target = target;
      }
      
      public Object getProxyInstance() {
          return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),
                                    new InvocationHandler() {
                                        @Override
                                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                            System.out.println("开启事务");
                                            
                                            Object returnValue = method.invoke(target, args);
                                            
                                            System.out.println("提交事务");
                                            
                                            return null;
                                        }
                                    });
      }
  }
  ```

* 测试类

  ```java
  public class TestProxy {
      @Test
      public void testDynamicProxy() {
          IUserDao target = new UserDao();
          System.out.println(target.getClass());
          IUserDao proxy = (IUserDao)new ProxyFactory(target).getPRoxyInstance();
          System,out.println(proxy.getClass());
          proxy.save();
      }
  }
  ```

CGLIB代理

* 目标类

  ```java
  public class Test {
      private final String a = "x";
  
      public void test() {
          System.out.println(a);
      }
  }
  ```

* 代理类

  ```java
  public class ProxyTest {
      private Object target;
  
      public ProxyTest(Object target) {
          this.target = target;
      }
  
      public Object getProxyInstance() {
          Enhancer enhancer = new Enhancer();
          enhancer.setSuperclass(Test.class);
          enhancer.setCallback(new MethodInterceptor() {
              @Override
              public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                  System.out.println("前置通知");
                  Object invoke = methodProxy.invokeSuper(o, objects);
                  System.out.println("后置通知");
                  return invoke;
              }
          });
          return enhancer.create();
      }
  }
  ```

* 测试类

  ```java
  public class Test {
      public static void main(String[] args) {
          Test test = new Test();
          ProxyTest proxyTest = new ProxyTest(test);
          Test proxyInstance = (Test) proxyTest.getProxyInstance();
          proxyInstance.test();
      }
  }
  ```

# 异常、断言和日志

## 处理错误

* 用户期望在出错误时，程序能够采取合理的行为。如果由于出现错误而使得某些操作灭有完成，程序应该：
  * 返回到一个安全状态，并能够让用户执行其他的命令
  * 允许用户保存所有工作的结果，并以妥善的方式终止程序
* 程序中可能存在的问题
  * 用户输入错误，除了那些不可避免地键盘输错误外，有些用户不准收程序的要求
  * 设备错误
  * 物理限制，磁盘已满，可能用尽了所有可用地存储空间
  * 代码错误，程序方法有可能没有正确地完成工作
* 如果不能采用正常的途径完成他的任务，可以通过另外一个路径退出方法，这种情况下，方法并不返回任何值，而是抛出一个封装了错误信息的对象
* 遇到异常后，这个方法将会立刻退出，并不返回正常值，也不会从调用这个方法的代码继续执行，取而代之的是，异常机制开始搜索能够处理这种异常状况的异常处理器

### 异常分类

* 异常对象都是派生于Throwable类的一个类实例，下一层立即分解为两个分支：Error和Exception
* Error类层次结构描述了Java运行时的系统的内部错误和资源耗尽错误
* Exception层次结构，又分为两个分支，一个分支派生于RuntimeException，另一个分支包含其他异常
* 一般规则：由于变成错误的异常属于RuntimeException，如果程序本身没有问题，但是由其他错误导致的异常属于其他异常
* Java语言规范将派生于Error类或RuntimeException类的所有异常称为非检查型异常，所有其他的异常称为检查性异常
* 需要抛出异常的情况：
  * 调用了一个抛出检查型异常的方法
  * 检测到一个错误，并且利用throw语句抛出一个检查型异常
  * 程序出现错误
  * Java虚拟机或运行时库出现内部错误
* 如果一个方法有可能抛出多个检查型异常类型，那么就必须在方法首部列出所有的异常类，每个异常类之间用逗号隔开
* 不应该声明从RuntimeException继承的那些非检查型异常
* 一个方法必须声明所有可能抛出的检查型异常，而非检查型异常要么在控制之外，要么从一开始就避免这种情况的发生

### 如何抛出异常

* 一旦方法抛出了异常，这个方法就不会返回到调用者，不必操心创建一个默认的返回值或错误码

### 创建异常类

* 创建异常类，需要定义一个派生于Exception的类，或者派生Exception的某个子类，自定义的这个类应该包含两个构造器，一个是默认的构造器，另一个是包含详细描述信息的构造器（超类Throwable的toString方法会返回一个字符串，其中包含这个详细信息）

## 创建异常

### 捕获异常

* 如果发生了某个异常，但没有在任何地方捕获这个异常，程序就会终止，并在控制台上打印一个消息，其中包含这个异常的类型和一个堆栈轨迹

* 要想捕获一个异常，需要设置try/catch语句块

  ```java
  try {
      code
  } catch (ExceptionType e) {
      handler for this type
  }
  ```

* 如果try语句块中的任何代码抛出了catch子句指定的一个异常类

  * 程序将跳过try语句块的其余代码
  * 程序将执行catch子句中的处理器代码

* 如果try语句块中没有抛出任何异常，那么程序将跳过catch子句

* 如果方法中的任意代码抛出了catch子句没有声明的一个异常类型，那么这个方法就会立即退出

* 如果调用了一个抛出检查型异常的方法，就必须执行这个异常，或者继续传递这个异常

* 一般来说，要捕获那些知如何处理的异常，而继续传播那些不知道怎么处理的异常

* 如果想传播一个异常，就必须在方法的首部添加一个throws说明符，提醒调用者这个方法可能会抛出异常

* 如果编写一个方法覆盖超累方法，而这个超类方法没有抛出异常，你就必须捕获你的方法代码中出现的每一个检查型异常

* 不允许在子类的throws说明符中出现超类方法未列出的异常类

### 捕获多个异常

* 在一个try语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理，要为每个异常类型使用一个单独的catch语句
* 想要获得这个对象的更多信息，可以尝试使用e.getMessage()方法
* 在Java7中，同一个catch子句中可以捕获多个异常类型（只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性）

### 再次抛出异常与异常链

* 可以在catch子句中抛出一个异常，通常希望改变异常的类型时胡这样做
* 捕获到新抛出的异常时，可以使用getCause获取原始异常
* 强烈建议使用这种包装技术，这样可以在子系统中抛出高层异常，而不会丢失原始异常的细节

### finally子句

* 代码抛出一个异常时，就会停止处理这个方法中剩余的代码，并退出这个方法
* 不管是否有异常被捕获，finally子句中的diamagnetic都会执行

### try-with-Resources语句

* 在java7中提供了一种方法

  ```java
  try (Resource res = ...) {
      work with res
  }
  ```

  他将自动关闭try语句段中资源

* 这个块正常退出时，或者存在一个异常时，都会调用close这个资源

> * 在java9中，可以在try首部中提供之前声明的事实最终变量

* try-with-Resources语句本身也可以youcatch子句，甚至还可以有一个finally子句，这些子句会在关闭资源之后执行

### 分析堆栈轨迹元素

* 堆栈轨迹是程序执行过程中某个特定点上所有挂起的方法调用的一个列表
* 可以调用Throwable类的printStackTrace方法访问贵站轨迹的文本描述信息
* 一种更灵活的方法是使用StackWalker类，它会生成要给StackWalker.StackFrame实例流，其中每个实例分别描述一个栈帧
* 使用异常的技巧
  * 异常处理不能代替简单测试
  * 不要过分地细化异常
  * 充分利用异常层次结构
  * 不要压制异常
  * 在检测错误时，“苛刻”总比放任好
  * 不要羞于传递异常

## 使用断言

### 断言的概念

* 使用常规的测试完毕后，这个代码还会一直保留在程序中，如果程序中含有大量这种检查，程序将会运行起来慢很多

* 断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查

* assert关键字，有两种形式：

  `assert condition;`

  和

  `assert condition : expression;`

  如果结果为false，则抛出一个AssertionError异常，第二个表达式中会将expression传入AssertionError对象的构造器，并且转换成一个消息字符串

### 启用和禁用断言

* 在默认情况下断言是禁止的，可以在运行程序时用-enableassertions或-ea选项启用断言

### 使用断言完成参数检查

* 什么时候使用断言
  * 断言失败是致命的，不可恢复的错误
  * 断言检查只是在开发和测试阶段打开
* 不应该使用断言向程序的其他部分通知发生了可恢复性的错误，或者，不应该利用断言与程序用户沟通问题
* 断言只应该用于在测试阶段确定程序内部错误的位置

## 日志

* 日志API为了解决代码中随处出现的System.out方法
  * 可以很容易的取消全部日志记录，或者仅仅取消某个级别以下的日志，而且可以很容易地再次打开日志开关
  * 可以很简单地禁止日志记录，因此，将这些日志代码留在程序中的开销很小
  * 日志记录可以被定向到不同的处理器
  * 日志记录器和处理器都可以对记录进行过滤。过滤器可以根据过滤器实现器指定的标准丢弃那些无用的记录项
  * 日志记录可以采用不同的方法格式化
  * 应用程序可以使用多个日志记录器，它们使用与报名类似的有层次结构的名字
  * 日志系统的配置有配置文件控制

### 基本日志

* 要完成简单的日志记录，可以使用全局日志记录器并调用其info方法

  `Logger.getGlobal().info(...)`

* 使用 `Logger.getGlobal().setLevel(Level.OFF)`将会取消所有日志

### 高级日志

* 可以调用getLogger方法创建或获取日志记录器

  `private static final Logger myLogger = Logger.getLogger("top.mnsx")`

* 与包名类似，日志记录器也具有层次结构，日志记录器的层次性更强

* 日志等级有7级：

  * SEVERE
  * WARNING
  * INFO
  * CONFIG
  * FINE
  * FINER
  * FINEST

* 在默认情况下，实际上只记录前3个级别

* 使用`logger.setLevel(Level.FINE)`，FINE以及所有更高级别的日志都会记录

* 可以使用Level.ALL开启所有级别的日志记录，或者使用Level.OFF关闭所有级别的日志记录

* 默认的日志记录将显示根据调用堆栈得出的包含日志调用的类名和方法名

* 如果虚拟机对执行过程进行了优化，就得不到准确的调用信息

* 可以使用logp方法获得调用类和方法的确切位置

  `void logp(Level l, String className, String methodName, String message)`

* 用来跟踪执行流的便利方法

  `void entering(String className, String methodName)`
  `void entering(String className, String methodName, Object param)`

  `void entering(String className, String methodName, Object[] params)`

  `void exiting(String className, String methodName)`

  `void exiting(String className, String methodName, Object result)`

* 记录日志的常见用途是记录那些预料之外的异常，可以使用下面两个便利方法在日志记录中包含异常的描述

  `void throwing(String className, String methodName, Throwable t)`

  `void log(Level l, String message, Throwable t)`

### 修改日志管理器配置

* 可以通过编辑配置文件来修改日志系统的各个属性，默认情况下，配置文件位于conf/logging.properties（或者在java9之前，位于jre/lib/logging.properties)

* 想要使用另一个配置文件，就要将java.util.logging.config.file属性设置为哪个文件的位置，为此将要用命令启动应用程序

  `java -Djava.utl.logging.config.file=configFile Main`

* 想要修改默认的日志级别，就需要编辑配置文件，并修改以下命令行

  `.level=INFO`

* 可以通过日志记录器名后面追加后缀.level来指定自定义日志记录器的日志级别

### 处理器

* 与日志记录器一样，处理器也有日志级别，对于一个要记录的日志记录，他的日志级别必须高于日志记录器和处理器二者的阈值

* 日志管理器配置文件将默认的控制台处理器的日志级别设置为`java.util.logging.ConsoleHandler.level=INFO`

* 想要记录更低级别的日志，就必须修改配置文件中的默认日志记录器级别和处理器级别，另外还可以绕过配置文件，安装你自己的处理器

  ```java
  Logger logger = Logger.getLogger("top.mnsx");
  logger.setLevel(Level.FINE);
  logger.setUseParentHandlers(false);
  ConsoleHandler handler = new ConsoleHandler();
  handler.setLevel(Level.FINE);
  logger.addHandler(handler);
  ```

* FileHandler是文件处理器，SocketHandler将记录发送到指定的主机和端口

* 使用FileHandler，这些记录被发送到用户主目录的javan.log文件中，n是保证文件唯一的一个编号（windows在C:\Windows)

  | 配置属性                                | 描述                                                         | 默认值                                                       |
  | --------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | java.util.logging.FileHandler.level     | 处理器级别                                                   | Level.ALL                                                    |
  | java.util.logging.FileHandler.append    | 控制处理器应该追加到一个已经存在的文件末尾，还是应该为每个运行的程序打开一个新文件 | false                                                        |
  | Java.util.logging.FileHandler.limit     | 在打开另一个文件之前允许写入一个文件的近似最大字节数（0表示无限） | 在FileHandler类中为0（表示无限制）在默认的日志管理器配置文件中为50000 |
  | java.util.logging.FIleHandler.pattern   | 日志文件名的模式                                             | %h/java%u.log                                                |
  | java.util.logging.FileHandler.count     | 循环序列中的日志记录数量                                     | 1                                                            |
  | java.util.logging.FileHandler.filter    | 要使用的过滤器类                                             | 不过滤                                                       |
  | java.util.logging.FileHandler.encoding  | 要使用的字符编码                                             | 平台的编码                                                   |
  | java.util.logging.FileHandler.formatter | 记录格式器                                                   | java.util.logging.XMLFormatter                               |

* 日志记录文件模式变量

  | 变量 | 描述                   |
  | ---- | ---------------------- |
  | %h   | 系统属性user.home的值  |
  | %t   | 系统临时目录           |
  | %u   | 用于解决冲突的唯一编号 |
  | %g   | 循环日志的生成号       |
  | %%   | %字符                  |

### 过滤器

* 在默认情况下，会根据日志记录的级别进行过滤，每个日志记录器和处理器都有一个可选的过滤器来完成附加的过滤，要定义一个过滤器，需要实现filter接口并定义以下方法

  `boolean isLoggable(LogRecord record)`

* 要想将一个过滤器安装到一个日志记录器或处理器中，只需要调用setFilter方法就可以，但是同一时刻最多只能有一个过滤器

### 格式化器

* 需要扩展Formatter类并覆盖`String format(LogRecord record)`方法
* `String formatMessage(LogRecord record)`这个方法对记录中的消息部分进行格式化，将替换参数并应用本地化处理

### 日志技巧

* 对一个简单的应用选择一个日志记录器，可以把日志记录器命名为与主应用包一样的名字
* 默认日志配置会把级别等于或高于INFO的所有消息记录到控制台，用户可以覆盖这个默认配置，但是过程非常复杂，最好在你的应用中安装一个更合适的默认配置
* 所有的级别为INFO、WARNING和SEVERE的消息都将显示在控制台上将想要的日志消息设置为FINE级别是一个很好的选择

## 调式技巧

* 在自定义类中应该重构toString方法来显示this对象的状态

* 可以在每一个类中放置一个单独的main方法，这样就可以提供一个单元测试桩，能够独立地测试类

* 可议使用JUnit单元测试框架

* 日志代理是一个子类对象，他可以截获方法调用，记录日志，然后调用超类中的方法

* 利用Throwable类的printStackTrace方法，可以从任意的异常对象获得堆栈轨迹

* 可以记录堆栈轨迹

  ```java
  StringWriter out = new StringWriter();
  new Throwable().printStackTrace(new PrintWriter(out));
  String description = out.toString();
  ```

* 在System.err中显示未捕获的异常的堆栈轨迹并不是一个理想的方法

* 要想观察类的加载过程，启动java虚拟机时可以使用-verbose标记

* -Xlint选项告诉编译器找出常见的代码问题

* Java虚拟机增加了对Java应用程序的监控和管理支持，允许在虚拟机中安装代理来跟踪内存消耗、线程使用、类加载等情况

# 泛型程序设计

## 为什么要使用泛型程序设计

* 泛型程序设计意味着编写的代码可以对多种不同类型的对象重用

### 类型参数的好处

* 泛型提供了一个更好的解决方法：类型参数

  `List<String> files = new ArrayList<>()`

* 编译器也可以充分利用这个类型信息，调用get的时候，不需要进行强制类型转换

* 使用类型参数，编译器可以检查，防止你插入错误类型的对象

### 使用泛型编程

* 泛型编程基本水平是，仅仅使用泛型类，而不考虑它们如何工作以及为什么这样做

## 定义简单泛型类

* 泛型类就是有一个或多个类型变量的类
* 泛型类引入一个类型变量T，用尖括号括起来，放在类名的后面
* 泛型类可以有多个类型变量
* 类型变量在整个类定义中用于指定方法的返回类型以及字段和局部变量的类型
* 可以用具体的类型替换类型变量来实例化泛型类型
* 泛型类相当于普通类的工厂

## 泛型方法

* 泛型方法可以在普通类中定义的，也可以在在泛型类中，类型放在放在修饰符的后面，并在返回类型的前面
* 当调用一个泛型方法时，可以把具体类型包围在尖括号中，放在方法名前面
* 编译器有时有足够的信息能够推断出你想要的泛型类型，它将参数的类型与泛型类型T进行匹配，推断出T的类型

## 类型变量的限定

* 可以对类型变量通过extends关键字进行限定

  `public static <T extends Comparable> T min(T[] a)`

* 限定类型通过&分隔，而逗号用来分隔类型变量

* 在Java继承中，可以根据需要拥有多个接口超类型，但最多有一个限定可以是类，如果有一个类作为限定，它必须是限定列表中的第一个限定

## 泛型代码和虚拟机

* 虚拟机没有泛型类型对象——所有对象都属于普通类

### 类型擦除

* 无论何时定义一个泛型类型，都会自动提供一个相应的原型类型
* 这个原始类型的名字就是去掉类型参数后的泛型类型名
* 类型变量会被擦除，并替换为其限定类型
* 因为T是一个无限顶的变量，所以直接用Object替换
* 原始类型用第一个限定来替换类型变量，或者，如果没有给定限定，就替换为Object

### 转换泛型表达式

* 编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换

### 转换泛型方法

* 类型擦除与多态发生了冲突，所以编译器在类中生成一个桥方法

  `pulbic void setSecond(Object second)`

* Java泛型转换

  * 虚拟机中没有泛型，只有普通类和方法
  * 所有的类型参数都会替换为它们的限定类型
  * 会合成桥方法来保持多态
  * 为保持类型安全性，必要时会插入强制类型转换

## 限制与局限性

[博客参考](https://blog.csdn.net/li0978/article/details/55193150)

### 不能用基本类型实例化类型参数

* 因为擦除后类型会变成Object类型，而Object不能存储基本类型

### 运行时类型查询只适合于原始类型

* 虚拟机中的对象总是有一个特定的非泛型类型，所有类型查询只产生原始类型

### 不能创建参数化类型的数组

* 因为擦除类型会被擦除为Object，所以数组中就能够放置多种类型，会被编译器报错

### Varargs警告

* 不能为可变数量参数设置泛型，因为其本质为数组
* 可以采用两种方法来抑制这个警告
  * 一种方法是为包含调用的方法增加注解@SuppressWarning("unchecked")
  * 或者在Java7中，还可以用@SafeVarargs直接注解在方法上
* @SafeVarargs只能声明在static、final或（Java9中）private的构造器和方法中

### 不能实例化类型变量

* 不能再类似new T(...)的表达式中使用类型变量

* 类型擦除将T变成Object，而你肯定不希望调用new Object()

* 解决方法

  * 在Java8之后，最好的解决方法是让调用者提供一个构造器表达式

    `Pair<String> p = Pair.makePair(String::new)`

    ```java
    public static <T> Pair<T> makePair(Supplier<T> constr) {
        return new Pair<>(constr.get(), constr.get());
    }
    ```

  * 比较传统的解决方法是通过反射调用Constructor.newInstance方法来构造泛型对象

### 不能构造泛型数组

* 数组本身也带有类型，用来监控虚拟机中的数组存储，这个类型将会被擦除。
* 如果数组仅仅作为一个类的私有实例字段，那么可以将这个数组的元素类型声明为擦除的类型并使用强制类型转换

### 泛型类的静态上下文类型变量无效

* 不能再静态字段或方法中引用类型变量
* 擦除后，所有泛型类型都会变成Object，子类变量不允许引用父类对象，必须要有强制类型转换，但是方法不知道应该返回什么类型，所以无法进行强制类型转换

### 不能抛出或捕获泛型类的实例

* 既不能抛出也不能捕获泛型类对象

### 可以取消对检查性异常的检查

* Java异常处理的一个基本原则是，必须为所有检查型异常提供了一个处理器

### 注意擦除后的冲突

* 当泛型类型被擦除后，不允许创建引用冲突的条件

## 泛型类型的继承规则

![](D:\WorkSpace\Note\Java后端笔记\Java\泛型列表类型中子类型间的关系.jpg)

## 通配符类型

### 通配符概念

* 在通配符类型中，允许类型参数发生变化

### 通配符的超类型限定

* 通过`? super xxx`可以指定一个超类型限定
* 使用超类限定的作用，可以为方法提供参数，但是不能使用返回值
* 带有超类型限定的通配符允许你写入一个泛型对象，而带有子类型限定的通配符允许你读取一个泛型对象

### 无限定通配符

* 还可以使用根本没有限定的通配符？
* 使用了无限定通配符可以使得任意Object对象调用无限定通配符方法

### 通配符捕获

* 无法使用？来声明变量，但是可以通过捕获通配符，来用？声明变量

  ```java
  public static <T> void swapHelper(Pair<T> p) {
      T t = ...
  }
  ```

* 通配符捕获只有在非常限定的情况下才是合法的，编译器必须能够保证通配符表示单个确定的类型

## 反射和泛型

### 泛型Class类

* Class类是泛型的
* 类型参数非常有用，这是因为允许Class<T>方法的返回类型更加具有特定性

### 虚拟机中的泛型类型信息

* Java泛型的突出特性之一是在虚拟机中擦除泛型类型
* 可以通过反射API确定：
  * 这个泛型方法有一个名为T的类型参数
  * 这个类型参数有一个子类型限定，其自身又是一个泛型类型
  * 这个限定类型有一个通配符参数
  * 这个通配符参数有一个超类型限定
  * 这个泛型方法有一个泛型数组参数
* 这个接口包含以下子类型：
  * Class类型，描述具体类型
  * TypeVariable接口，描述类型便来给你
  * WildcardType接口，描述通配符
  * ParameterizedType接口， 描述泛型类或接口类型
  * GenericArrayType接口，描述泛型数组
