# 认识时间复杂度

常数时间的操作 

一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。 

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体 来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作， 进而总结出常数操作数量的表达式。 

在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那 么时间复杂度为O(f(N))。 

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行 时间，也就是“常数项时间”。

## 选择排序、冒泡排序细节的讲解与复杂度分析

时间复杂度O(N^2)，额外空间复杂度O(1)

* 选择排序

  ```java
  public class SelectionSort {
      private static Scanner scanner = new Scanner(System.in);
  
      private static int[] dataIn() {
          System.out.println("输入数组长度:");
          int length = scanner.nextInt();
          int[] ints = new int[length];
          System.out.println("输入数组的内容:");
          for (int i = 0; i < length; ++i) {
              ints[i] = scanner.nextInt();
          }
          return ints;
      }
  
      public static void main(String[] args) {
          int[] ints = dataIn();
          display(ints);
          selectionSort(ints);
          display(ints);
      }
  
      private static void display(int[] ints) {
          for (int i : ints) {
              System.out.print(i + " ");
          }
      }
  
      private static void selectionSort(int[] ints) {
          int length = ints.length;
  
          for (int i = 0; i < length - 1; ++i) {
              int min = i;
              for (int j = i + 1; j < length; ++j) {
                  if (ints[j] < ints[min]) {
                      min = j;
                  }
              }
              if (min != i) {
                  swap(ints, i, min);
              }
          }
      }
  
      private static void swap(int[] ints, int i, int j) {
          ints[i] = ints[i] ^ ints[j];
          ints[j] = ints[i] ^ ints[j];
          ints[i] = ints[i] ^ ints[j];
      }
  }
  
  ```

* 冒泡排序

  ```java
  public class BubbleSort {
      private static Scanner scanner = new Scanner(System.in);
  
      private static int[] dataIn() {
          System.out.println("输入数组长度:");
          int length = scanner.nextInt();
          int[] ints = new int[length];
          System.out.println("输入数组的内容:");
          for (int i = 0; i < length; ++i) {
              ints[i] = scanner.nextInt();
          }
          return ints;
      }
  
      public static void main(String[] args) {
          int[] ints = dataIn();
          display(ints);
          bubbleSort(ints);
          display(ints);
      }
  
      private static void display(int[] ints) {
          for (int i : ints) {
              System.out.print(i + " ");
          }
      }
  
      private static void bubbleSort(int[] ints) {
          int length = ints.length;
  
          for (int i = 0; i < length - 1; ++i) {
              for (int j = i + 1; j < length; ++j) {
                  if (ints[i] > ints[j]) {
                      swap(ints, i, j);
                  }
              }
          }
      }
  
      private static void swap(int[] ints, int i, int j) {
          ints[i] = ints[i] ^ ints[j];
          ints[j] = ints[i] ^ ints[j];
          ints[i] = ints[i] ^ ints[j];
      }
  }
  ```

## 插入排序细节的讲解与复杂度分析

时间复杂度O(N^2)，额外空间复杂度O(1) 

算法流程按照最差情况来估计时间复杂度

```java
public class InsertionSort {
    private static Scanner scanner = new Scanner(System.in);

    private static int[] dataIn() {
        System.out.println("输入数组长度:");
        int length = scanner.nextInt();
        int[] ints = new int[length];
        System.out.println("输入数组的内容:");
        for (int i = 0; i < length; ++i) {
            ints[i] = scanner.nextInt();
        }
        return ints;
    }

    public static void main(String[] args) {
        int[] ints = dataIn();
        display(ints);
        insertionSort(ints);
        display(ints);
    }

    private static void display(int[] ints) {
        for (int i : ints) {
            System.out.print(i + " ");
        }
    }

    private static void insertionSort(int[] ints) {
        int length = ints.length;

        for (int i = 1; i < length; ++i) {
            int j = i;
            int temp = ints[i];
            while (j > 0 && temp < ints[j - 1]) {
                ints[j] = ints[j - 1];
                j--;
            }
            if (j != i) {
                ints[j] = temp;
            }
        }
    }
}
```

## 异或运算的性质与扩展

1）0^N == N N^N == 0 

2）异或运算满足交换律和结合率 

3）不用额外变量交换两个数 

4）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数 

5）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数

## 二分法的详解与扩展

1）在一个有序数组中，找某个数是否存在 

2）在一个有序数组中，找>=某个数最左侧的位置 

3）局部最小值问题

## 对数器的概念和使用

1，有一个你想要测的方法a 

2，实现复杂度不好但是容易实现的方法b 

3，实现一个随机样本产生器 

4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。 

5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者 方法b 

6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。





剖析递归行为和递归行为时间复杂度的估算 用递归方法找一个数组中的最大值，系统上到底是怎么做的？ master公式的使用 T(N) = a*T(N/b) + O(N^d) 1) log(b,a) > d -> 复杂度为O(N^log(b,a)) 2) log(b,a) = d -> 复杂度为O(N^d * logN) 3) log(b,a) < d -> 复杂度为O(N^d) 补充阅读:www.gocalf.com/blog/algorithm-complexity-and-master- theorem.html